<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo-512x512.png" color="#222">
  <meta name="google-site-verification" content="jZ7dJJlouQrswxytAryX3LanLNrTthfFdMUkDJzRqIU">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.keychan.xyz","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 为什么 async&#x2F;await 不能解决并发问题Swift Concurrency 带来的第一个直观变化，是 async&#x2F;await 让异步调用读起来像同步代码。之前一长串回调嵌套，现在可以按顺序写清楚：先请求网络，再解析，再更新状态。但在真实项目里，异步“写起来舒服”只是表面，很多时候真正的痛点不在于“怎么写异步逻辑”，而在于“多个任务同时访问同一份状态时发生的问题”。">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 隔离式并发实践：actor、Global Actor 与 Sendable">
<meta property="og:url" content="https://www.keychan.xyz/2025/12/09/046-swift-concurrency/index.html">
<meta property="og:site_name" content="KeyChan&#39;s blog">
<meta property="og:description" content="1. 为什么 async&#x2F;await 不能解决并发问题Swift Concurrency 带来的第一个直观变化，是 async&#x2F;await 让异步调用读起来像同步代码。之前一长串回调嵌套，现在可以按顺序写清楚：先请求网络，再解析，再更新状态。但在真实项目里，异步“写起来舒服”只是表面，很多时候真正的痛点不在于“怎么写异步逻辑”，而在于“多个任务同时访问同一份状态时发生的问题”。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-09T12:35:12.000Z">
<meta property="article:modified_time" content="2025-12-09T13:10:28.450Z">
<meta property="article:author" content="KeyChan">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Swift并发">
<meta property="article:tag" content="actor">
<meta property="article:tag" content="AsyncSequence">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.keychan.xyz/2025/12/09/046-swift-concurrency/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.keychan.xyz/2025/12/09/046-swift-concurrency/","path":"2025/12/09/046-swift-concurrency/","title":"Swift 隔离式并发实践：actor、Global Actor 与 Sendable"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Swift 隔离式并发实践：actor、Global Actor 与 Sendable | KeyChan's blog</title>
  







<link rel="dns-prefetch" href="https://comment.mengyajia.com">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="KeyChan's blog" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">KeyChan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-随想"><a href="/think/" rel="section"><i class="fa fa-lightbulb fa-fw"></i>随想</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-async-await-%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">1. 为什么 async&#x2F;await 不能解决并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%8F%AA%E6%9C%89-async-await%EF%BC%8C%E5%B9%B6%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E9%85%8D%E7%BD%AE%E7%8A%B6%E6%80%81%E5%AE%89%E5%85%A8"><span class="nav-text">1.1 只有 async&#x2F;await，并不能保证配置状态安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E7%89%B9%E5%88%AB%E5%AE%B9%E6%98%93%E8%B8%A9%E5%B9%B6%E5%8F%91%E5%9D%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">1.2 获取服务端配置特别容易踩并发坑的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%A0%B9%E6%9C%AC%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%AF%E5%8F%98%E7%8A%B6%E6%80%81%E6%B2%A1%E6%9C%89%E2%80%9C%E5%BD%92%E5%B1%9E%E2%80%9D"><span class="nav-text">1.3 根本问题：可变状态没有“归属”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%BC%95%E5%85%A5-ConfigStore%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98%E5%8F%AA%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA-actor-%E8%AE%BF%E9%97%AE"><span class="nav-text">1.4 引入 ConfigStore：配置缓存只通过一个 actor 访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%86%8D%E5%BE%80%E5%A4%96%E4%B8%80%E5%B1%82%EF%BC%9A%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E6%9C%AC%E8%BA%AB%E4%B9%9F%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B"><span class="nav-text">1.5 再往外一层：刷新流程本身也需要独立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E5%9C%A8-MainActor"><span class="nav-text">1.6 状态更新在 MainActor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Swift-Actor-%E9%9A%94%E7%A6%BB%E4%BD%93%E7%B3%BB%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text">2. Swift Actor 隔离体系：获取服务端配置的三层结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%9A%94%E7%A6%BB%E5%9F%9F%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%80%8C%E6%98%AF%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F%E7%9A%84%E2%80%9C%E5%94%AF%E4%B8%80%E5%85%A5%E5%8F%A3%E2%80%9D"><span class="nav-text">2.1 隔离域的本质：不是线程，而是访问顺序的“唯一入口”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ConfigStore%EF%BC%9A%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98%E7%9A%84%E7%8B%AC%E5%8D%A0%E9%9A%94%E7%A6%BB%E5%9F%9F"><span class="nav-text">2.2 ConfigStore：配置缓存的独占隔离域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ConfigFetcher%EF%BC%9A%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%BA%A7%E9%9A%94%E7%A6%BB%E5%9F%9F"><span class="nav-text">2.3 ConfigFetcher：刷新流程的业务级隔离域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-ConfigViewModel%EF%BC%9A%E7%95%8C%E9%9D%A2%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%9F%9F"><span class="nav-text">2.4 ConfigViewModel：界面状态的主线程隔离域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E4%B8%89%E5%B1%82%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8A%B6%E6%80%81%E6%B5%81%E5%8A%A8%E7%BB%93%E6%9E%84"><span class="nav-text">2.5 三层隔离的状态流动结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Sendable%EF%BC%9A%E8%B7%A8%E9%9A%94%E7%A6%BB%E5%9F%9F%E4%BC%A0%E9%80%92%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E6%9C%89%E6%B8%85%E6%99%B0%E8%BE%B9%E7%95%8C"><span class="nav-text">3. Sendable：跨隔离域传递的数据必须有清晰边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%B7%A8%E9%9A%94%E7%A6%BB%E5%9F%9F%E4%BC%A0%E9%80%92"><span class="nav-text">3.1 数据是否需要跨隔离域传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%BA%E4%BB%80%E4%B9%88-ConfigSnapshot-%E5%BF%85%E9%A1%BB%E6%98%AF-struct"><span class="nav-text">3.2 为什么 ConfigSnapshot 必须是 struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88-raw-%E5%AD%97%E6%AE%B5%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-String-Any"><span class="nav-text">3.3 为什么 raw 字段不能使用 [String: Any]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E4%B8%BA%E4%BB%80%E4%B9%88-ConfigSnapshot-%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA-MainActor"><span class="nav-text">3.4 为什么 ConfigSnapshot 不能被标记为 @MainActor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Sendable%EF%BC%9A%E8%B7%A8%E9%9A%94%E7%A6%BB%E5%9F%9F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BE%B9%E7%95%8C"><span class="nav-text">3.5 Sendable：跨隔离域的类型边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-ConfigSnapshot%EF%BC%9A%E6%AF%8F%E4%B8%80%E6%9D%A1%E7%BA%A6%E6%9D%9F%E9%83%BD%E4%B8%BA%E8%B7%A8%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="nav-text">3.6 ConfigSnapshot：每一条约束都为跨域服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Task-%E4%B8%8E-await%EF%BC%9A%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9A%94%E7%A6%BB%E5%9F%9F%E4%B9%8B%E9%97%B4%E7%A9%BF%E6%A2%AD"><span class="nav-text">4. Task 与 await：异步流程如何在隔离域之间穿梭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Task-%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%80%8C%E6%98%AF%E4%B8%80%E6%AE%B5%E5%8F%AF%E9%9A%8F%E6%97%B6%E6%9A%82%E5%81%9C%E5%92%8C%E7%BB%A7%E7%BB%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91"><span class="nav-text">4.1 Task 不是线程，而是一段可随时暂停和继续的异步逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-await-%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%90%AB%E4%B9%89%EF%BC%9A%E8%AE%A9%E5%87%BA%E6%89%A7%E8%A1%8C%E6%9D%83%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E6%9F%90%E4%BB%B6%E4%BA%8B"><span class="nav-text">4.2 await 的真正含义：让出执行权，而不是等待线程完成某件事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-actor-%E5%86%85%E9%83%A8%E7%9A%84-await-%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%9A%E6%9A%82%E5%81%9C%E6%97%B6%E5%85%81%E8%AE%B8%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1%E8%BF%9B%E5%85%A5"><span class="nav-text">4.3 actor 内部的 await 会触发可重入：暂停时允许其他任务进入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E4%B8%BA%E4%BB%80%E4%B9%88-ConfigFetcher-%E4%B8%AD%E7%9A%84-await-%E4%B8%8D%E4%BC%9A%E9%80%A0%E6%88%90%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E8%A2%AB%E6%89%93%E6%96%AD"><span class="nav-text">4.4 为什么 ConfigFetcher 中的 await 不会造成刷新流程被打断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-store-%E7%9A%84-setAll-%E5%92%8C-currentSnapshot-%E7%9A%84-await-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">4.5 store 的 setAll 和 currentSnapshot 的 await 执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-await-%E6%9A%82%E5%81%9C%E7%82%B9%E5%AF%B9%E4%B8%9A%E5%8A%A1%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">4.6 await 暂停点对业务正确性的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E7%A9%BF%E8%B6%8A%E9%9A%94%E7%A6%BB%E5%9F%9F"><span class="nav-text">4.7 任务如何穿越隔离域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-actor-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%EF%BC%9A%E4%BF%9D%E8%AF%81%E4%B8%9A%E5%8A%A1%E4%B8%8D%E8%A2%AB%E6%89%93%E4%B9%B1"><span class="nav-text">5. actor 的可重入性：保证业务不被打乱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E9%81%87%E5%88%B0-await-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%80%80%E5%87%BA-actor%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%BB%96%E8%B0%83%E7%94%A8%E8%BF%9B%E6%9D%A5"><span class="nav-text">5.1 可重入的本质：遇到 await 时必须退出 actor，让其他调用进来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-ConfigStore-%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E7%A0%B4%E5%9D%8F%E5%AD%98%E5%82%A8%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">5.2 ConfigStore 是可重入的，但不会破坏存储一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E5%B1%9E%E4%BA%8E%E4%B8%9A%E5%8A%A1%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">5.3 刷新流程属于业务关键路径，因此不能被可重入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E4%B8%BA%E4%BB%80%E4%B9%88-ConfigFetcher-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%8C%E8%80%8C-ConfigStore-%E5%8F%AF%E4%BB%A5"><span class="nav-text">5.4 为什么 ConfigFetcher 不可重入，而 ConfigStore 可以</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9C%9F%E6%AD%A3%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">5.5 可重入真正可能造成问题的场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Swift-%E5%B9%B6%E5%8F%91%E5%9C%A8%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E8%90%BD%E5%9C%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">6. Swift 并发在架构中的落地方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E8%B5%84%E6%BA%90%E5%B1%82%EF%BC%88ConfigStore%EF%BC%89%E6%98%AF%E7%8A%B6%E6%80%81%E7%9A%84%E5%94%AF%E4%B8%80%E5%85%A5%E5%8F%A3"><span class="nav-text">6.1 第一层：资源层（ConfigStore）是状态的唯一入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E6%B5%81%E7%A8%8B%E5%B1%82%EF%BC%88ConfigRefreshService-ConfigFetcher%EF%BC%89%E5%AE%9A%E4%B9%89%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E9%A1%BA%E5%BA%8F"><span class="nav-text">6.2 第二层：流程层（ConfigRefreshService + ConfigFetcher）定义业务逻辑顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9AUI%E5%B1%82%EF%BC%88ConfigViewModel%EF%BC%89%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E5%8F%AF%E8%A7%81%E7%8A%B6%E6%80%81"><span class="nav-text">6.3 第三层：UI层（ConfigViewModel）管理用户可见状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E4%B8%89%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E5%BD%A2%E6%88%90%E8%87%AA%E7%84%B6%E5%88%86%E5%B7%A5"><span class="nav-text">6.4 三层之间的调用链路形成自然分工</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E9%81%BF%E5%85%8D%E5%9C%A8%E6%B5%81%E7%A8%8B%E5%B1%82%E5%86%85%E9%83%A8%E5%87%BA%E7%8E%B0%E6%84%8F%E5%A4%96%E7%9A%84%E6%9A%82%E5%81%9C%E7%82%B9"><span class="nav-text">6.5 避免在流程层内部出现意外的暂停点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%9A%E4%BB%8E%E5%8D%95%E4%B8%80%E9%85%8D%E7%BD%AE%E8%B5%B0%E5%90%91%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-text">6.6 架构的可扩展性：从单一配置走向多模块并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-Swift-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%B7%E5%80%BC%EF%BC%9A%E8%AE%A9%E7%8A%B6%E6%80%81%E3%80%81%E6%B5%81%E7%A8%8B%E3%80%81%E7%95%8C%E9%9D%A2%E5%90%84%E5%8F%B8%E5%85%B6%E8%81%8C"><span class="nav-text">6.7 Swift 并发的架构价值：让状态、流程、界面各司其职</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E4%B8%8E%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-text">7. 常见并发问题与隔离模型的解决方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%87%A0%E4%B9%8E%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%B5%8B"><span class="nav-text">7.1 多个任务几乎同时刷新，导致最终版本不可预测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E7%8A%B6%E6%80%81%E5%86%99%E5%85%A5%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E6%AD%A5%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%9C%A8-await-%E6%9A%82%E5%81%9C%E6%97%B6%E6%9A%B4%E9%9C%B2%E5%8D%8A%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="nav-text">7.2 状态写入如果有多步，可能在 await 暂停时暴露半更新状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B%E5%9C%A8%E7%AD%89%E5%BE%85%E7%BD%91%E7%BB%9C%E8%BF%94%E5%9B%9E%E6%97%B6%E8%A2%AB%E6%8F%92%E9%98%9F%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B5%81%E7%A8%8B%E9%80%BB%E8%BE%91%E6%B7%B7%E4%B9%B1"><span class="nav-text">7.3 刷新流程在等待网络返回时被插队，导致流程逻辑混乱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-UI-%E5%9C%A8%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%AE%B9%E6%98%93%E5%AF%BC%E8%87%B4%E5%B4%A9%E6%BA%83%E6%88%96%E7%8A%B6%E6%80%81%E8%B7%B3%E8%B7%83"><span class="nav-text">7.4 UI 在后台线程更新，容易导致崩溃或状态跳跃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%B7%A8%E9%9A%94%E7%A6%BB%E4%BC%A0%E9%80%92%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%84%8F%E5%A4%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89"><span class="nav-text">7.5 共享引用对象跨隔离传递，导致意外的数据竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81%E4%B8%8E%E6%89%8B%E5%8A%A8%E5%88%B7%E6%96%B0%E5%8F%AF%E8%83%BD%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%9C%80%E7%BB%88%E7%8A%B6%E6%80%81%E9%94%99%E8%AF%AF"><span class="nav-text">7.6 服务端推送与手动刷新可能乱序执行，导致最终状态错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-7-%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E5%90%8E%E5%8F%B0%E8%BF%98%E5%9C%A8%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E6%97%A7%E9%80%BB%E8%BE%91"><span class="nav-text">7.7 任务取消不生效，后台还在继续执行旧逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-%E9%9A%94%E7%A6%BB%E6%9C%AC%E8%B4%A8%E4%B8%8A%E4%B8%8D%E6%98%AF%E2%80%9C%E9%81%BF%E5%85%8D-bug%E2%80%9D%EF%BC%8C%E8%80%8C%E6%98%AF%E2%80%9C%E6%B6%88%E7%81%AD-bug-%E7%9A%84%E5%8F%91%E7%94%9F%E6%9D%A1%E4%BB%B6%E2%80%9D"><span class="nav-text">7.8 隔离本质上不是“避免 bug”，而是“消灭 bug 的发生条件”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Swift-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%95%B4%E4%BD%93%E8%A7%86%E9%87%8E%EF%BC%9A%E4%BB%8E%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="nav-text">8. Swift 并发的整体视野：从隔离模型构建可预测的系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-Swift-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">8.1 Swift 并发的核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%89%E5%B1%82%E4%BD%93%E7%B3%BB"><span class="nav-text">8.2 获取服务端配置示例构建的三层体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-Swift-%E5%B9%B6%E5%8F%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%8F%AF%E9%A2%84%E6%B5%8B%E2%80%9D%E7%9A%84"><span class="nav-text">8.3 Swift 并发是如何让系统“可预测”的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-text">8.4 隔离模型的可扩展性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E4%BB%8E%E2%80%9C%E9%9D%A2%E5%90%91%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E2%80%9D%E5%88%B0%E2%80%9C%E9%9A%94%E7%A6%BB%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%9D"><span class="nav-text">8.5 从“面向线程编程”到“隔离式编程”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E6%80%BB%E7%BB%93"><span class="nav-text">8.6 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%A4%87%E6%B3%A8"><span class="nav-text">9. 备注</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KeyChan"
      src="/images/key_avatar.png">
  <p class="site-author-name" itemprop="name">KeyChan</p>
  <div class="site-description" itemprop="description">全干工程师</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:kckeychan@gmail.com" title="E-Mail → mailto:kckeychan@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/keychankc" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;keychankc" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.keychan.xyz/2025/12/09/046-swift-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/key_avatar.png">
      <meta itemprop="name" content="KeyChan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KeyChan's blog">
      <meta itemprop="description" content="全干工程师">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Swift 隔离式并发实践：actor、Global Actor 与 Sendable | KeyChan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift 隔离式并发实践：actor、Global Actor 与 Sendable
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-09 20:35:12 / 修改时间：21:10:28" itemprop="dateCreated datePublished" datetime="2025-12-09T20:35:12+08:00">2025-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS-%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS 开发</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/12/09/046-swift-concurrency/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/12/09/046-swift-concurrency/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>57 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-为什么-async-await-不能解决并发问题"><a href="#1-为什么-async-await-不能解决并发问题" class="headerlink" title="1. 为什么 async&#x2F;await 不能解决并发问题"></a>1. 为什么 async&#x2F;await 不能解决并发问题</h2><p>Swift Concurrency 带来的第一个直观变化，是 async&#x2F;await 让异步调用读起来像同步代码。之前一长串回调嵌套，现在可以按顺序写清楚：先请求网络，再解析，再更新状态。但在真实项目里，异步“写起来舒服”只是表面，很多时候真正的痛点不在于“怎么写异步逻辑”，而在于“多个任务同时访问同一份状态时发生的问题”。线程变多、任务变多、入口变多之后，只要可变状态没有明确的限制，就可能带来问题。</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/keychankc/be207faff229cc2b97da168aaf9aadb7">获取服务端配置</a>就是一个非常典型的并发场景：有本地缓存，有后台刷新，有多处调用，有UI依赖结果，还有可能叠加服务端推送。表面上只是“拉一份配置下来”，但内部状态在多个任务之间来回穿插，如果不做隔离，async&#x2F;await 并不能有效处理这些逻辑。</p>
<span id="more"></span>
<h3 id="1-1-只有-async-await，并不能保证配置状态安全"><a href="#1-1-只有-async-await，并不能保证配置状态安全" class="headerlink" title="1.1 只有 async&#x2F;await，并不能保证配置状态安全"></a>1.1 只有 async&#x2F;await，并不能保证配置状态安全</h3><p>我们从最原始的方式出发，常见写法往往是先声明一份全局缓存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config: [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台任务在某个时机写入</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    config[<span class="string">&quot;featureA&quot;</span>] <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI在显示时读取</span></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value <span class="operator">=</span> config[<span class="string">&quot;featureA&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表面上已经完全进入 Swift Concurrency 语境，没有回调地狱，全部换成了 Task 和 await，看上去都是“现代写法”。但共享状态本身是裸奔的。这两个 Task 可能在任何时间并发运行：一边写入，一边读取，甚至在写入过程中的某个中间状态被读取。轻则逻辑错乱，重则触发崩溃。</p>
<p>而且从模型角度看，async&#x2F;await 解决的是“控制流的表达方式”，并没有解决“谁在什么时刻可以访问这份状态”。异步链路变线性了，但状态访问的顺序仍然没有约束。</p>
<h3 id="1-2-获取服务端配置特别容易踩并发坑的原因"><a href="#1-2-获取服务端配置特别容易踩并发坑的原因" class="headerlink" title="1.2 获取服务端配置特别容易踩并发坑的原因"></a>1.2 获取服务端配置特别容易踩并发坑的原因</h3><p>获取服务端配置这件事，看起来只是“拉一份 JSON 然后更新缓存”，实际步骤还是不少的：</p>
<ul>
<li>本地缓存需要保存当前配置字典</li>
<li>后台可能有定时任务轮询配置</li>
<li>部分业务接口调用前会校验版本是否最新</li>
<li>UI根据配置决定是否显示功能开关</li>
<li>后续如果接入服务端推送时，配置还可能被动更新</li>
</ul>
<p>如果这些动作统统围绕同一块 <code>[String: Any]</code> 展开，风险包括：</p>
<ul>
<li>某次刷新还在更新部分字段，另一条任务已经开始读</li>
<li>版本判断刚做完，另一个任务用旧数据覆盖了新配置</li>
<li>UI渲染时拿到的是“半更新”的快照</li>
<li>日志里的版本号和真实生效版本对不上</li>
</ul>
<p>这类问题不是语法错误，而是时序错误。代码一行一行看都讲得通，只要执行顺序有一点点抖动，结果立刻改变。靠 async&#x2F;await 把“单条调用链”的顺序写明白，只解决了局部问题，无法约束“多条链同时跑时的访问关系”。</p>
<h3 id="1-3-根本问题：可变状态没有“归属”"><a href="#1-3-根本问题：可变状态没有“归属”" class="headerlink" title="1.3 根本问题：可变状态没有“归属”"></a>1.3 根本问题：可变状态没有“归属”</h3><p>如果把问题点压缩成一句话，就是：<strong>一份可变状态被很多地方同时操作，没有任何一个组件为它负最终责任。</strong> 最原始的写法里，配置缓存就是那一行 <code>var config: [String: Any]</code>。但是后台能改，网络层能改，业务层也能改，UI某些地方也可能顺手改一部分。访问既没有中介，也没有边界。</p>
<p>在并发模型下，这种状态迟早会出问题。无论是通过 async&#x2F;await 调用，还是用 GCD、OperationQueue，只要状态处于“谁都能摸一下”的状态，复杂度上升之后风险就会扩大。Swift 并发真正想改变的，不是“回调怎么写”，而是“状态怎么被看待”：可变状态不再直接暴露给整个系统，而是被封进一个隔离域，所有访问必须通过排队进入这个隔离域。</p>
<h3 id="1-4-引入-ConfigStore：配置缓存只通过一个-actor-访问"><a href="#1-4-引入-ConfigStore：配置缓存只通过一个-actor-访问" class="headerlink" title="1.4 引入 ConfigStore：配置缓存只通过一个 actor 访问"></a>1.4 引入 ConfigStore：配置缓存只通过一个 actor 访问</h3><p>在完整示例里，配置缓存不再是一个散落在全局的字典，而是收进了一个专门的 actor：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">ConfigStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">set</span>(<span class="params">key</span>: <span class="type">String</span>, <span class="params">value</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">        storage[key] <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setAll</span>(<span class="keyword">_</span> <span class="params">dict</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) &#123;</span><br><span class="line">        storage <span class="operator">=</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="keyword">Any</span><span class="operator">?</span> &#123;</span><br><span class="line">        storage[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentVersion</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        storage[<span class="string">&quot;version&quot;</span>] <span class="keyword">as?</span> <span class="type">Int</span> <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个关键变化点：</p>
<ul>
<li>可变状态 storage 不再到处可见，而是被牢牢关在 ConfigStore 里面。外部代码无法直接操作字典，只能通过方法访问。</li>
<li>所有访问 storage 的操作，都必须通过 await store.xxx() 进入。Swift 在这里可以自动保证：同一时刻只有一个任务在 ConfigStore 内执行，所有读写都会被排成队列顺序完成。</li>
<li>从其他隔离域直接访问 storage 的尝试会被编译器阻止，只能通过 ConfigStore 暴露的接口来读写。这相当于给配置缓存加了门禁。</li>
</ul>
<p>换个说法：配置这块状态，从“谁都能碰”的公共区域，变成了“只属于 ConfigStore”这一小块隔离空间，想进来必须排队。<br>光是这一层改造，就比单纯引入 async&#x2F;await 安全得多。</p>
<h3 id="1-5-再往外一层：刷新流程本身也需要独立"><a href="#1-5-再往外一层：刷新流程本身也需要独立" class="headerlink" title="1.5 再往外一层：刷新流程本身也需要独立"></a>1.5 再往外一层：刷新流程本身也需要独立</h3><p>缓存归属 ConfigStore 之后，还有一个问题没有解决：<strong>刷新这条业务链路，谁来负责顺序？</strong> 获取服务端配置的完整流程大致是这样一条链：</p>
<ol>
<li>读取本地版本号</li>
<li>请求服务端获取最新配置</li>
<li>比对版本，判断是否需要更新</li>
<li>写入本地缓存</li>
<li>生成 ConfigSnapshot 返回给上层</li>
</ol>
<p>如果这条链路允许多条任务同时执行，即使底层 storage 的读写是串行化的，整个刷新流程依然可能被时序打乱。典型情况是两条刷新逻辑前后脚进来：</p>
<ul>
<li>两条任务在同一时刻读取到相同的本地版本，</li>
<li>各自判断“需要刷新”，</li>
<li>各自发起网络请求，</li>
<li>各自写入结果，</li>
<li>各自返回快照。</li>
</ul>
<p>问题不在于 storage 是否串行，而在于<strong>版本判断、网络请求、写回缓存这几个步骤本质上是一条需要保持顺序的业务链路</strong>。一旦并发执行，网络返回顺序、调度顺序、写入时机都可能不同步，最终生效的配置可能来自任意一条任务。即便有一条链路拿到了更新的版本，也很可能被另一条链路的旧数据覆盖。</p>
<p>换句话说，在没有明确“业务隔离”的前提下，刷新流程的逻辑顺序并没有被保护，最终状态可能不是业务上的“最新配置”。这种不确定性会在高并发或弱网场景下被放大，很难预期，也难排查。为此示例里引入了一个全局 actor：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@globalActor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigFetcher</span> &#123;</span><br><span class="line">    <span class="keyword">actor</span> <span class="title class_">ActorType</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">ActorType</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新服务还是用普通 class，只在方法上挂上 ConfigFetcher：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigRefreshService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> api: <span class="type">ConfigAPIProtocol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> store: <span class="type">ConfigStore</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">api</span>: <span class="type">ConfigAPIProtocol</span>, <span class="params">store</span>: <span class="type">ConfigStore</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.api <span class="operator">=</span> api</span><br><span class="line">        <span class="keyword">self</span>.store <span class="operator">=</span> store</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ConfigFetcher</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">refreshIfNeeded</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> localVersion <span class="operator">=</span> <span class="keyword">await</span> store.currentVersion()</span><br><span class="line">        <span class="keyword">let</span> remote <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> api.fetchConfig()</span><br><span class="line">        <span class="keyword">guard</span> remote.version <span class="operator">&gt;</span> localVersion <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> store.setAll(remote.asDictionary())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ConfigFetcher</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forceRefresh</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> remote <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> api.fetchConfig()</span><br><span class="line">        <span class="keyword">await</span> store.setAll(remote.asDictionary())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个细节：</p>
<ul>
<li>类本身没有标记 @ConfigFetcher，只有方法标注。这样构造 ConfigRefreshService 时不必进入全局 actor，避免额外的隔离开销，把隔离精确应用到真正需要顺序保障的刷新流程上。</li>
<li>只要是刷新相关的方法，入口都被统一挂在 ConfigFetcher 上。无论多少任务同时调用 refreshIfNeeded 或 forceRefresh，真正执行这些方法时都会排队进入 ConfigFetcher 的隔离域。</li>
</ul>
<p>这样的结果就是<strong>刷新逻辑从“可能并发交错的一堆任务”，收束成“同一时间只有一条刷新任务在跑的串行队列”</strong>。 业务对“配置更新”就变成了一次只处理一个版本切换——在语言层面被牢牢限制。</p>
<h3 id="1-6-状态更新在-MainActor"><a href="#1-6-状态更新在-MainActor" class="headerlink" title="1.6 状态更新在 MainActor"></a>1.6 状态更新在 MainActor</h3><p>最外层是UI状态，这部分也需要独立归属。示例中的 ViewModel 写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> refreshService: <span class="type">ConfigRefreshService</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> snapshot: <span class="type">ConfigSnapshot</span> <span class="operator">=</span> .empty</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> lastError: <span class="type">Error</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">refreshService</span>: <span class="type">ConfigRefreshService</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.refreshService <span class="operator">=</span> refreshService</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadOnLaunch</span>() &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> loadConfig()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">manualRefresh</span>() &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> loadConfig(force: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">loadConfig</span>(<span class="params">force</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span>) <span class="keyword">async</span> &#123;</span><br><span class="line">        isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        lastError <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newSnapshot: <span class="type">ConfigSnapshot</span></span><br><span class="line">            <span class="keyword">if</span> force &#123;</span><br><span class="line">                newSnapshot <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> refreshService.forceRefresh()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newSnapshot <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> refreshService.refreshIfNeeded()</span><br><span class="line">            &#125;</span><br><span class="line">            snapshot <span class="operator">=</span> newSnapshot</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            lastError <span class="operator">=</span> error</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isFeatureAEnabled: <span class="type">Bool</span> &#123;</span><br><span class="line">        snapshot.featureAEnabled</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isFeatureBEnabled: <span class="type">Bool</span> &#123;</span><br><span class="line">        snapshot.featureBEnabled</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里处理了几件事情：</p>
<ul>
<li>所有UI相关状态（snapshot、isLoading、lastError）都被放在 MainActor 下，自动遵循“只能在主线程读写 UI 状态”的要求，不需要显式写 DispatchQueue.main.async。</li>
<li>UI并不直接接触 ConfigStore，ViewModel 拿到的是 ConfigSnapshot 这种只读值类型，刷新完成后一次性替换，UI 层不参与任何缓存读写逻辑。</li>
<li>UI也不处理版本判断、请求细节、缓存写入顺序。所有这些业务细节都被收敛在 ConfigRefreshService 和 ConfigFetcher 里，ViewModel 只负责触发刷新和展示结果。</li>
</ul>
<p>到这里，获取服务端配置这条链路已经形成了三个清晰的归属：</p>
<ul>
<li>配置缓存交给 ConfigStore    </li>
<li>刷新流程交给 ConfigFetcher &#x2F; ConfigRefreshService</li>
<li>界面状态交给 MainActor 下的 ConfigViewModel</li>
</ul>
<p>数据在这些隔离域之间流转时，交由 ConfigSnapshot 这种值类型承载，不再直接暴露底层字典。</p>
<p><strong>本章小结：async&#x2F;await 负责“流程”，隔离负责“结构”</strong><br>回到开头的问题：为何 async&#x2F;await 不能单独解决并发安全？原因可以归纳成一句话：<br><strong>async&#x2F;await 让“单条异步链路”更易读，但获取服务端配置这种场景真正敏感的是“多条链路同时运行时，状态更新有没有限制”</strong>。如果配置缓存只是一个全局变量，谁都能读写，即便全部换成 async&#x2F;await，底层结构仍然是不安全的。只有做到三点，代码在并发场景下才有机会保持稳定：</p>
<ul>
<li>配置缓存归属 ConfigStore 这样的 actor，所有读写排队进入</li>
<li>刷新流程归属 ConfigFetcher 这样的全局 actor，保证串行执行</li>
<li>界面状态归属 MainActor，使用 ConfigSnapshot 这样的 Sendable 值在隔离域之间传递</li>
</ul>
<p>后面的章节，会在这条示例链路之上继续展开：</p>
<ul>
<li>actor、Global Actor、MainActor 在隔离行为上有哪些细微差异</li>
<li>Sendable 如何约束 ConfigSnapshot 等模型在隔离域间移动</li>
<li>Task 与 await 在中途暂停时，会如何影响执行顺序和可重入行为</li>
<li>接入服务端推送与 AsyncSequence 后，这套结构如何扩展而不失控</li>
</ul>
<p>整个讨论都围绕这一个案例展开，争取从一个具体场景里，把 Swift 并发的结构性思路拆开讲清楚。</p>
<h2 id="2-Swift-Actor-隔离体系：获取服务端配置的三层结构"><a href="#2-Swift-Actor-隔离体系：获取服务端配置的三层结构" class="headerlink" title="2. Swift Actor 隔离体系：获取服务端配置的三层结构"></a>2. Swift Actor 隔离体系：获取服务端配置的三层结构</h2><p>上一章从整体视角说明了 async&#x2F;await 为什么无法单独保证并发安全，也展示了获取服务端配置这条链路里三块状态的归属问题：配置缓存、刷新流程、界面状态。</p>
<p>这一章还是以这段代码为核心，详细拆解 Swift 提供的三种隔离方式：普通 actor、全局 actor、MainActor。它们如何分别承担三类状态的独占管理职责，又是如何共同构成一个稳定的架构层次。</p>
<p>在这套结构中，actor 并不是“新的语法糖”，而是有非常明确的业务含义：谁可以访问这份状态、访问顺序如何决定、跨域移动数据时会发生什么，每一项都有严格的语言语义束缚着。理解这三种隔离的角色关系，基本等于理解 Swift 并发机制的核心。</p>
<h3 id="2-1-隔离域的本质：不是线程，而是访问顺序的“唯一入口”"><a href="#2-1-隔离域的本质：不是线程，而是访问顺序的“唯一入口”" class="headerlink" title="2.1 隔离域的本质：不是线程，而是访问顺序的“唯一入口”"></a>2.1 隔离域的本质：不是线程，而是访问顺序的“唯一入口”</h3><p>“隔离域”这个概念听起来很抽象，但在工程语境下非常好理解。它描述的不是线程，而是访问某种状态的唯一入口。获取服务端配置这个业务里，有三块状态彼此独立：</p>
<ul>
<li>本地缓存字典</li>
<li>刷新流程的版本判断与写入步骤</li>
<li>UI层的快照状态及加载标志</li>
</ul>
<p>如果这三块状态都散落在各处，由不同代码同时读取或修改，那么并发行为很难控制；即便每条逻辑单独看都完全正确，一旦多条任务同时运行，状态顺序马上变得不可预测。Swift 的做法是让这些状态分别属于不同的隔离域：</p>
<ul>
<li>本地存储属于 ConfigStore（普通 actor）</li>
<li>刷新流程属于 ConfigFetcher（全局 actor）</li>
<li>UI 状态属于 MainActor</li>
</ul>
<p>这三个隔离域都在不同的“执行环境”工作，各自拥有明确的职责——谁可以访问状态、访问顺序如何保证、跨域访问时需要使用 await。这样结构化的划分让系统更可推断，也让编译器能够帮助约束访问路径。</p>
<h3 id="2-2-ConfigStore：配置缓存的独占隔离域"><a href="#2-2-ConfigStore：配置缓存的独占隔离域" class="headerlink" title="2.2 ConfigStore：配置缓存的独占隔离域"></a>2.2 ConfigStore：配置缓存的独占隔离域</h3><p>配置缓存是整个业务里最核心的一份可变状态——如果它被多个任务同时访问时出错，所有流程都会受影响。现在的写法将这份状态完全托管给 ConfigStore：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">ConfigStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">set</span>(<span class="params">key</span>: <span class="type">String</span>, <span class="params">value</span>: <span class="keyword">Any</span>) &#123;</span><br><span class="line">        storage[key] <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setAll</span>(<span class="keyword">_</span> <span class="params">dict</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) &#123;</span><br><span class="line">        storage <span class="operator">=</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">key</span>: <span class="type">String</span>) -&gt; <span class="keyword">Any</span><span class="operator">?</span> &#123;</span><br><span class="line">        storage[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentVersion</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        storage[<span class="string">&quot;version&quot;</span>] <span class="keyword">as?</span> <span class="type">Int</span> <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码实现的效果非常直接：谁要读写这份 storage，都必须经过 ConfigStore，外界没有直接操作权限。内部执行也严格按照顺序排队，不会出现多个任务同时执行 actor 内部的任何语句。Swift 并发在这里提供的是“语言级别的排他访问”：不需要锁，不需要队列，也不需要额外辅助结构。更重要的是，ConfigStore 不负责业务判断，只负责存储一致性。这种“最小化职责”的设计，使得它既稳定又容易维护。</p>
<h3 id="2-3-ConfigFetcher：刷新流程的业务级隔离域"><a href="#2-3-ConfigFetcher：刷新流程的业务级隔离域" class="headerlink" title="2.3 ConfigFetcher：刷新流程的业务级隔离域"></a>2.3 ConfigFetcher：刷新流程的业务级隔离域</h3><p>缓存虽然被保护好了，但刷新流程本身也有强烈的顺序要求。一个典型的刷新需要：</p>
<ul>
<li>检查当前版本</li>
<li>拉取最新配置</li>
<li>比对决定是否更新</li>
<li>写入缓存</li>
<li>生成快照给上层</li>
</ul>
<p>如果这条流程同时被多条任务触发，就算底层 store 是串行访问，也会出现逻辑上的互相覆盖、错序或震荡。刷新流程的解决方式，是把它放进一个全局 actor：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@globalActor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigFetcher</span> &#123;</span><br><span class="line">    <span class="keyword">actor</span> <span class="title class_">ActorType</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">ActorType</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再让刷新方法显式标注：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigFetcher</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">refreshIfNeeded</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span></span><br></pre></td></tr></table></figure>
<p>调用行为因此被改变：无论有多少任务同时触发刷新，真正执行刷新逻辑时，都必须排队进入 ConfigFetcher 的隔离环境。刷新流程从“可能并发”变成“严格串行”，业务顺序完全可控。</p>
<p>此外，全局 actor 与普通 actor 最大的区别在于：全局范围内只有一份“业务隔离域”。不论在哪个模块发起刷新，都归入这一条业务通路。这在大型应用中可以避免大量细碎的锁与队列管理。</p>
<h3 id="2-4-ConfigViewModel：界面状态的主线程隔离域"><a href="#2-4-ConfigViewModel：界面状态的主线程隔离域" class="headerlink" title="2.4 ConfigViewModel：界面状态的主线程隔离域"></a>2.4 ConfigViewModel：界面状态的主线程隔离域</h3><p>SwiftUI 和 UIKit 都要求 UI 更新必须在主线程执行，因此UI相关状态天然有自己的隔离域。示例中通过：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigViewModel</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>
<p>明确表达UI状态只能在 MainActor 内访问。这带来了以下效果：</p>
<ul>
<li>snapshot、isLoading、lastError 等 UI 状态不会在后台线程被错误更新</li>
<li>刷新流程返回快照时，会自动切回主线程更新 UI</li>
<li>不再需要显式写 DispatchQueue.main.async</li>
</ul>
<p>界面层仅关心 ConfigSnapshot，完全不需要知道 ConfigStore 或 ConfigFetcher 的存在；三层之间通过值传递形成天然的解耦。这样设计后，UI 层不会触碰任何后台可变状态，后台逻辑也不会直接影响 UI 的线程上下文，职责边界彻底分离。</p>
<h3 id="2-5-三层隔离的状态流动结构"><a href="#2-5-三层隔离的状态流动结构" class="headerlink" title="2.5 三层隔离的状态流动结构"></a>2.5 三层隔离的状态流动结构</h3><p>从 UI 发起请求开始，到配置返回给 UI 更新，就有了一条稳定、可预测的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainActor（UI）</span><br><span class="line">    → 请求刷新（进入 ConfigFetcher）</span><br><span class="line">ConfigFetcher（刷新流程）</span><br><span class="line">    → 读取 / 写入缓存（进入 ConfigStore）</span><br><span class="line">ConfigStore（存储层）</span><br><span class="line">    → 构造快照（跨域返回）</span><br><span class="line">ConfigFetcher</span><br><span class="line">    → 返回结果</span><br><span class="line">MainActor（UI）</span><br><span class="line">    → 更新界面状态</span><br></pre></td></tr></table></figure>
<p>每一步都有明确的职责，每一个状态都有属于自己的隔离域。没有地方能绕开这些隔离域，开发者不需要时刻思考“这个地方是不是需要加锁”或“是不是会被后台线程修改”。更关键的是，这种结构天然具备扩展性：如果要接入服务端推送时，只需要让推送更新也进入 ConfigFetcher，不需要改动缓存层或 UI。</p>
<p><strong>本章小结：三种 actor 构成三类状态的天然分层</strong><br>可以将这一章的核心思想总结为一句话：<strong>Swift 并发不是让异步写法变漂亮，而是让可变状态在系统中有“归属”、有“边界”、有“秩序”</strong>。在“获取服务端配置”这一个例子里，三类状态的分层关系非常明确：</p>
<ul>
<li>配置缓存归 ConfigStore</li>
<li>刷新流程归 ConfigFetcher</li>
<li>UI 状态归 MainActor</li>
</ul>
<p>每一层都有自己的隔离域，彼此不越界。任务在 await 间穿梭，但状态访问始终稳定。下一章会深入 Sendable，解释为什么 ConfigSnapshot 必须设计成值类型，为什么不能直接返回一个 class，以及跨隔离域传递数据时编译器如何帮助保证安全。</p>
<h2 id="3-Sendable：跨隔离域传递的数据必须有清晰边界"><a href="#3-Sendable：跨隔离域传递的数据必须有清晰边界" class="headerlink" title="3. Sendable：跨隔离域传递的数据必须有清晰边界"></a>3. Sendable：跨隔离域传递的数据必须有清晰边界</h2><p>前一章讲了获取服务端配置这套结构中三类状态分别有属于各自的隔离域：ConfigStore、ConfigFetcher 与 MainActor。隔离域负责“状态在何处被访问”这个问题，但还缺一块同样重要的拼图——状态在隔离域之间如何流动？</p>
<p>从 ConfigStore 创建快照，到 ConfigFetcher 处理结果，再到 UI 更新状态，都会涉及跨隔离域的数据传递。一旦传递的数据里夹带可变引用类型，或包含某块后台共享的状态，整个隔离系统都会被绕开，从而重新回到“谁都能改”的混乱状态。</p>
<p>Swift 提供的 Sendable 协议就是为了解决这类问题。它不是语法糖，而是一条类型级别的安全边界：哪些数据能跨隔离域移动、哪些数据不能、哪些必须被约束为不可变值类型，都由编译器在编译期间检查。这一章的核心，就是解释为什么 ConfigSnapshot 必须是值类型、必须符合 Sendable，以及为什么 raw 字段不能直接使用 <code>[String: Any]</code>。</p>
<h3 id="3-1-数据是否需要跨隔离域传递"><a href="#3-1-数据是否需要跨隔离域传递" class="headerlink" title="3.1 数据是否需要跨隔离域传递"></a>3.1 数据是否需要跨隔离域传递</h3><p>在当前的架构中，一次刷新过程会让快照按照这样一条路径流动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConfigStore（actor）</span><br><span class="line">    → 构造 ConfigSnapshot</span><br><span class="line">    → 返回给 ConfigFetcher（全局 actor）</span><br><span class="line">    → 最终返回给 MainActor（UI）</span><br></pre></td></tr></table></figure>
<p>这条路径跨越三个隔离域。只要路径上出现引用类型，或者包含共享可变的对象，隔离域就无法保证状态不会被其他任务改写。Sendable 就是为了提前阻止这类情况。快照本身是 “后台产出 → 主线程使用” 的典型类型，毫无疑问需要跨域。要让这条数据流可靠，必须设计成完全不可变的结构体。</p>
<h3 id="3-2-为什么-ConfigSnapshot-必须是-struct"><a href="#3-2-为什么-ConfigSnapshot-必须是-struct" class="headerlink" title="3.2 为什么 ConfigSnapshot 必须是 struct"></a>3.2 为什么 ConfigSnapshot 必须是 struct</h3><p>如果快照以 class 表达：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigSnapshotRef</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> featureAEnabled: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> featureBEnabled: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并从 actor 返回它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshotRef</span> &#123;</span><br><span class="line">    <span class="type">ConfigSnapshotRef</span>(<span class="operator">...</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会出现问题，因为<strong>class 是引用类型</strong>，多个隔离域拿到的是同一个实例，任何地方修改版本号或开关状态，其他隔离域都会“随之改变”。这直接破坏 ConfigStore 的隔离语义，也让 UI 拿到的快照不再是“某一刻的结果”，而成了“某个共享对象”。</p>
<p>Swift 会阻止这种行为。可变引用类型默认不符合 Sendable，一旦试图从 actor 返回，编译器会直接报错。这是 Swift 并发的设计思路之一：跨隔离域的数据不能依赖共享引用。而 struct 只复制，不共享内部状态，只要字段本身也符合 Sendable，就可以保证快照是独立的，后续不会被任何后台任务修改。</p>
<h3 id="3-3-为什么-raw-字段不能使用-String-Any"><a href="#3-3-为什么-raw-字段不能使用-String-Any" class="headerlink" title="3.3 为什么 raw 字段不能使用 [String: Any]"></a>3.3 为什么 raw 字段不能使用 [String: Any]</h3><p>业务上往往希望把服务端返回的所有字段原样保存下来，因此 ConfigSnapshot 会包含一个 “raw 字段”：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> raw: [<span class="type">String</span>: <span class="type">AnySendable</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line"><span class="keyword">let</span> raw: [<span class="type">String</span>: <span class="keyword">Any</span>]</span><br></pre></td></tr></table></figure>
<p>原因很简单：Any 不是 Sendable。Any 可以装任意东西，包括闭包、class 实例、可变引用等。把它放进跨域传递的数据结构里，编译器无法判断是否安全，只能编译报错。为了允许 raw 字段跨域流动，又不破坏类型安全，需要一个受控的包装类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AnySendable</span>: <span class="title class_ inherited__">Sendable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">case</span> int(<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设计它的目的是为了确保：</p>
<ul>
<li>raw 内部所有值都符合 Sendable</li>
<li>不允许出现可变引用</li>
<li>整体结构可以跨隔离域传递</li>
</ul>
<p>这是 Swift 并发的一个思想体现：跨域数据必须经过显式表达，不能留有模糊空间。</p>
<h3 id="3-4-为什么-ConfigSnapshot-不能被标记为-MainActor"><a href="#3-4-为什么-ConfigSnapshot-不能被标记为-MainActor" class="headerlink" title="3.4 为什么 ConfigSnapshot 不能被标记为 @MainActor"></a>3.4 为什么 ConfigSnapshot 不能被标记为 @MainActor</h3><p>很多人在一开始会尝试这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigSnapshot</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在 ConfigStore 里创建 snapshot：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">    <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器立即报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call to main actor-isolated initializer in a synchronous actor-isolated context</span><br></pre></td></tr></table></figure>
<p>错误内容其实非常直接，一个标记为 @MainActor 的类型，其初始化必须在主线程执行。但当前代码在后台 actor 内构造它，这是一个同步构造过程，无法跨隔离运行，Swift 只能拒绝。快照的正确使用方式应该是不使用任何 actor，这样才可以在任意隔离域之间自由移动。</p>
<p>换句话说，快照本质上是“数据”，不属于 UI、后台或业务调度者。它是流动在各层之间的载体，不应绑定线程，不应绑定 actor。</p>
<h3 id="3-5-Sendable：跨隔离域的类型边界"><a href="#3-5-Sendable：跨隔离域的类型边界" class="headerlink" title="3.5 Sendable：跨隔离域的类型边界"></a>3.5 Sendable：跨隔离域的类型边界</h3><p>当 ConfigStore 返回快照时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span></span><br></pre></td></tr></table></figure>
<p>Swift 会检查ConfigSnapshot 是否 Sendable、内部字段是否存在引用类型、是否存在跨域无法预测的可变状态。跨域传递只会在满足 Sendable 条件时被允许，否则就会报错。</p>
<p>Sendable 让跨域数据流的安全成为编译期规则，快照之所以能在 ConfigStore → ConfigFetcher → MainActor 之间走得那么自然，就是因为 Sendable 的约束确保它在所有隔离域里都是独立、安全、不可变的值。</p>
<h3 id="3-6-ConfigSnapshot：每一条约束都为跨域服务"><a href="#3-6-ConfigSnapshot：每一条约束都为跨域服务" class="headerlink" title="3.6 ConfigSnapshot：每一条约束都为跨域服务"></a>3.6 ConfigSnapshot：每一条约束都为跨域服务</h3><p>快照的特征如下：struct 值类型、完全不可变、不依赖 UI 或后台资源、内部字段都是值类型、符合 Sendable、不属于任何 actor。这些特征共同达成一种结构：</p>
<ul>
<li>在后台构造完全安全</li>
<li>在流程层传递不共享引用</li>
<li>在主线程使用不需额外切换</li>
<li>在任何任务中都不会被修改</li>
</ul>
<p>这一点非常重要：<strong>快照不是共享对象，而是一个“时间点的定格”。</strong> UI 永远看到的是当时完整的配置，不会因后台后续写入而改变。</p>
<p><strong>本章小结：Sendable 规定的是“能不能跨域传”，不是“怎么传”</strong><br>隔离域决定谁可以访问状态；Sendable 决定哪些状态可以离开隔离域。在配置系统中，三层隔离域相互独立，但通过值类型快照形成了稳定的跨域数据流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigStore → ConfigSnapshot → ConfigFetcher → MainActor</span><br></pre></td></tr></table></figure>
<p>这一条数据链路之所以稳定可靠，是因为：</p>
<ul>
<li>快照完全不可变</li>
<li>raw 字段受控</li>
<li>不存在共享引用</li>
<li>编译器提前阻止风险</li>
</ul>
<p>Sendable 是 Swift 并发中经常被忽略但最关键的一环，它把跨域数据的安全从开发行为约束变成了强制编译规则。没有 Sendable，这套结构的安全性将完全不存在。</p>
<p>下一章会继续以这个示例为背景，从 Task 与 await 的角度分析刷新流程中发生的暂停点、任务切换、可重入行为，以及它们与隔离域之间的关系。</p>
<h2 id="4-Task-与-await：异步流程如何在隔离域之间穿梭"><a href="#4-Task-与-await：异步流程如何在隔离域之间穿梭" class="headerlink" title="4. Task 与 await：异步流程如何在隔离域之间穿梭"></a>4. Task 与 await：异步流程如何在隔离域之间穿梭</h2><p>获取服务端配置这条链路在运行时，会经历多个异步阶段：界面发起刷新、流程层判断版本、后台拉取配置、写入本地缓存、构造快照、更新界面状态。整个过程并不是一条单向直跑的流程，而是不断跨越隔离域、不断暂停与继续执行的协作流程。</p>
<p>Swift 并发里，Task 和 await 是所有动作的载体，它们不是线程的包装，而是完全由语言调度的异步协作单元。理解 Task 和 await 如何在隔离域间流转，决定了能否看懂整个“刷新配置”在运行时的真实流程。下面结合实际代码，把任务模型的核心机制从表象到本质展开，使整个架构的运行行为变得可观察、可推断、可验证。</p>
<h3 id="4-1-Task-不是线程，而是一段可随时暂停和继续的异步逻辑"><a href="#4-1-Task-不是线程，而是一段可随时暂停和继续的异步逻辑" class="headerlink" title="4.1 Task 不是线程，而是一段可随时暂停和继续的异步逻辑"></a>4.1 Task 不是线程，而是一段可随时暂停和继续的异步逻辑</h3><p>UI层启动配置加载的方式很直接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadOnLaunch</span>() &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> loadConfig()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一行代码不会创建新的线程，而是把 loadConfig() 包装成一个任务交给调度器，让调度器决定它具体在哪个线程执行。</p>
<p>在 Swift Concurrency 中，Task 并不是传统意义上的线程，而是“协程”这一更高层次的抽象。协程最大的特征是可以在执行过程中暂停，然后在未来某个时刻恢复，而且恢复时不要求继续运行在同一个线程上。暂停点由 await 决定，而不是由线程决定。</p>
<p>当代码运行到 await 时，任务会把当前执行状态保存下来，线程随即被释放，用于执行其他任务。这意味着系统可以在极低成本下同时调度大量异步任务，而不需要像传统线程那样长期占用系统资源。当等待的异步操作完成后（例如网络响应到达），任务再被调度器恢复，继续从暂停的位置往下执行。</p>
<p>这种模型让 Swift 能够用同步写法表达异步流程，同时具备协程式的高吞吐能力，不会因为某个耗时操作而阻塞线程，也不会因为线程数量不足而限制并发规模。简而言之，Swift 的异步任务更像“可暂停的逻辑片段”，而不是“一条长久占用资源的执行轨道”。</p>
<p>在这一点上，Swift 并发与 GCD 的理念完全不同：<strong>GCD 分派的是“要执行的事情”，Swift 分派的是“能够暂停、恢复的执行结构”</strong>。</p>
<h3 id="4-2-await-的真正含义：让出执行权，而不是等待线程完成某件事"><a href="#4-2-await-的真正含义：让出执行权，而不是等待线程完成某件事" class="headerlink" title="4.2 await 的真正含义：让出执行权，而不是等待线程完成某件事"></a>4.2 await 的真正含义：让出执行权，而不是等待线程完成某件事</h3><p>刷新配置的流程里，有许多 await：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localVersion <span class="operator">=</span> <span class="keyword">await</span> store.currentVersion()</span><br><span class="line"><span class="keyword">let</span> remote <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> api.fetchConfig()</span><br><span class="line"><span class="keyword">await</span> store.setAll(remote.asDictionary())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br></pre></td></tr></table></figure>
<p>await 的行为不只是“等待结果”，而是两个动作：</p>
<ol>
<li>暂停当前任务</li>
<li>把执行权交还给调度器</li>
</ol>
<p>这个暂停是协作式的。线程不会被锁住，而是继续执行其他任务。当 await 的内容完成后（例如网络请求返回），任务再继续往下执行。刷新流程的每一段 await 都是潜在的挂起点：</p>
<ul>
<li>版本读取可能挂起</li>
<li>网络请求一定挂起</li>
<li>写入缓存可能挂起</li>
<li>读取快照可能挂起</li>
</ul>
<p>这些暂停点让任务具有极强的弹性，系统能在高并发情况下保持稳定运行。</p>
<h3 id="4-3-actor-内部的-await-会触发可重入：暂停时允许其他任务进入"><a href="#4-3-actor-内部的-await-会触发可重入：暂停时允许其他任务进入" class="headerlink" title="4.3 actor 内部的 await 会触发可重入：暂停时允许其他任务进入"></a>4.3 actor 内部的 await 会触发可重入：暂停时允许其他任务进入</h3><p>Swift 的 actor 不是传统意义上的“锁住一段代码直到结束”。actor 保证的是执行片段的串行化，而不是整个方法的串行化。例如 ConfigStore：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">ConfigStore</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然构造快照是同步的，但方法本身是 async，因此对外界来说一定需要 await：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> snap <span class="operator">=</span> <span class="keyword">await</span> store.currentSnapshot()</span><br></pre></td></tr></table></figure>
<p>这一 await 让调用者暂停，ConfigStore 也有机会处理其他任务。</p>
<p>actor 的行为总结为一句话：只要遇到 await，当前任务会退出 actor，让其他任务进入。这种行为叫可重入，是提升吞吐量的关键机制。在获取服务端配置的案例中，这种可重入不会破坏存储一致性，因为写操作是整体替换（setAll），读操作也是一次性读取（snapshot），不存在“部分更新状态被读取”的风险。</p>
<h3 id="4-4-为什么-ConfigFetcher-中的-await-不会造成刷新流程被打断"><a href="#4-4-为什么-ConfigFetcher-中的-await-不会造成刷新流程被打断" class="headerlink" title="4.4 为什么 ConfigFetcher 中的 await 不会造成刷新流程被打断"></a>4.4 为什么 ConfigFetcher 中的 await 不会造成刷新流程被打断</h3><p>刷新流程的核心位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigFetcher</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">refreshIfNeeded</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> localVersion <span class="operator">=</span> <span class="keyword">await</span> store.currentVersion()</span><br><span class="line">    <span class="keyword">let</span> remote <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> api.fetchConfig()</span><br><span class="line">    <span class="keyword">await</span> store.setAll(remote.asDictionary())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便其中包括长时间暂停（fetchConfig），整个方法也不会被其他刷新流程打断。原因在于 ConfigFetcher 是一个全局 actor。全局 actor（包括 MainActor）与普通 actor 最大的差异是：<strong>在 await 时不会让出执行域，其他任务无法“插队”</strong>。执行线程可以让给系统，但执行权不会让给同一全局 actor 的其他任务。这使得业务流程的顺序绝对稳定，不会出现刷新逻辑交错执行的问题。这种“不可重入性”正是刷新流程所需的语义：<strong>刷新必须顺序执行，不能被其他刷新流程抢占</strong>。</p>
<h3 id="4-5-store-的-setAll-和-currentSnapshot-的-await-执行流程"><a href="#4-5-store-的-setAll-和-currentSnapshot-的-await-执行流程" class="headerlink" title="4.5 store 的 setAll 和 currentSnapshot 的 await 执行流程"></a>4.5 store 的 setAll 和 currentSnapshot 的 await 执行流程</h3><p>刷新流程内部跨越了多个隔离域，写入缓存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入缓存</span></span><br><span class="line"><span class="keyword">await</span> store.setAll(<span class="operator">...</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造快照</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> store.currentSnapshot()</span><br></pre></td></tr></table></figure>
<p>从 ConfigFetcher（全局 actor）跨越到 ConfigStore（普通 actor），然后再回到 ConfigFetcher，最后返回给MainActor。</p>
<p>这条路径体现了 Swift 并发的真正运行方式：任务不断在隔离域之间切换执行，状态的访问顺序由隔离域保证，而流程的执行顺序由任务逻辑保证。线程如何切换、在哪个物理 CPU 上运行，与整个逻辑没有关系。所有隔离行为由类型结构而不是线程结构来定义。</p>
<h3 id="4-6-await-暂停点对业务正确性的影响"><a href="#4-6-await-暂停点对业务正确性的影响" class="headerlink" title="4.6 await 暂停点对业务正确性的影响"></a>4.6 await 暂停点对业务正确性的影响</h3><p>在 Swift 并发中，最常见的误区是只是把 await 当作“等待”。但其实 await 是业务结构中的关键节点：</p>
<ul>
<li>await 会打断当前逻辑，让后续操作延迟执行</li>
<li>await 会让流程处于“未完成状态”</li>
<li>await 允许隔离域切换</li>
<li>await 是插队的窗口（对普通 actor）</li>
<li>await 是任务取消的机会点</li>
</ul>
<p>在示例中之所以有效，是因为整个结构针对暂停点做了对应的匹配：</p>
<ul>
<li>ConfigFetcher 保证暂停不会破坏流程顺序</li>
<li>ConfigStore 保证暂停不会导致存储中间态泄漏</li>
<li>ConfigSnapshot 保证暂停不会暴露部分构造结果</li>
<li>MainActor 保证暂停不会让 UI 落到后台线程</li>
</ul>
<p>这些匹配构成一个完整的系统，让 await 在任意位置出现都不会损坏业务逻辑。</p>
<h3 id="4-7-任务如何穿越隔离域"><a href="#4-7-任务如何穿越隔离域" class="headerlink" title="4.7 任务如何穿越隔离域"></a>4.7 任务如何穿越隔离域</h3><p>以下是一次完整刷新动作的实际执行轨迹：</p>
<ul>
<li>MainActor 发起任务：loadOnLaunch()</li>
<li>任务进入 ConfigFetcher：调用 refreshIfNeeded</li>
<li>跨域进入 ConfigStore：读取版本号</li>
<li>返回 ConfigFetcher：继续流程</li>
<li>遇到 fetchConfig：任务挂起，执行器释放</li>
<li>网络返回后恢复任务</li>
<li>跨域进入 ConfigStore：写入缓存</li>
<li>返回 ConfigFetcher：准备生成快照</li>
<li>跨域进入 ConfigStore：读取最终快照</li>
<li>返回 ConfigFetcher</li>
<li>返回 MainActor</li>
<li>UI 更新 snapshot</li>
</ul>
<p>这条链路说明一件事，整个系统的逻辑顺序是可推断的，隔离域的结构让状态安全，await 的协作式模型让并发变得轻量且可维护。异步变得直观的原因不是 async&#x2F;await 本身，而是 async&#x2F;await 在隔离域规则下具有明确行为。</p>
<p><strong>本章小结：Task 决定流程，await 决定节奏，隔离域决定结构</strong><br>获取服务端配置示例展示的不是“如何用 async&#x2F;await 写异步代码”，而是：</p>
<ul>
<li>Task 承载业务流程</li>
<li>await 让任务以协作方式运行</li>
<li>ConfigStore 保护后台状态</li>
<li>ConfigFetcher 保证刷新顺序</li>
<li>MainActor 保证界面更新</li>
<li>ConfigSnapshot 让数据在隔离域之间安全流动</li>
</ul>
<p>这套结构使得系统在复杂的并发环境中保持稳定、可预测和可维护。下一章我们将从更多工程细节角度切入——可重入的实际影响、什么时候会导致严重业务错乱、哪些逻辑必须避免在 actor 内 await，以及如何正确处理关键步骤的连续性。</p>
<h2 id="5-actor-的可重入性：保证业务不被打乱"><a href="#5-actor-的可重入性：保证业务不被打乱" class="headerlink" title="5. actor 的可重入性：保证业务不被打乱"></a>5. actor 的可重入性：保证业务不被打乱</h2><p>Swift actor 的行为与传统锁存在本质差异。传统锁强调“进入后一直持有到退出”，而 Swift 的 actor 更像一个“门卫”：一次只允许一个任务进入执行，但如果执行过程中遇到 await，任务必须退出，让其他等待中的调用进入。这种机制称为可重入（Reentrancy）。</p>
<p>可重入提高了并发吞吐能力，却也可能让业务逻辑在暂停与恢复之间出现顺序错乱。获取服务端配置中同时使用了普通 actor 和全局 actor，正是为了让“哪些逻辑可以被可重入”与“哪些逻辑绝不能被可重入”形成稳定的边界。本章从示例代码出发，说明可重入机制的本质、影响、风险点，以及如何保证在这些行为下仍然保证严格的业务顺序。</p>
<h3 id="5-1-可重入的本质：遇到-await-时必须退出-actor，让其他调用进来"><a href="#5-1-可重入的本质：遇到-await-时必须退出-actor，让其他调用进来" class="headerlink" title="5.1 可重入的本质：遇到 await 时必须退出 actor，让其他调用进来"></a>5.1 可重入的本质：遇到 await 时必须退出 actor，让其他调用进来</h3><p>下面是一个具有典型可重入行为的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">        doSomeLocalWork()      <span class="comment">// 在 actor 内执行</span></span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="operator">...</span>)  <span class="comment">// 暂停点</span></span><br><span class="line">        doMoreWork()           <span class="comment">// 恢复后继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流会这样展开：</p>
<ol>
<li>第一次进入 actor，执行前半部分</li>
<li>遇到 await，任务暂时离开 actor</li>
<li>actor 可以处理其他任务</li>
<li>await 完成后，原任务重新进入 actor，继续执行下半部分</li>
</ol>
<p>换句话说，actor 内部只有“不包含 await 的连续片段”是绝对串行的。一旦出现 await，该片段就结束了，执行权让给其他调用。可重入是 Swift 为提高性能所做的设计，使得某个 actor 在面对大量调用时不会被长任务完全阻塞。但这带来另一个问题：如果代码逻辑依赖“前半段状态必须与后半段状态连续一致”，await 就会带来问题。</p>
<h3 id="5-2-ConfigStore-是可重入的，但不会破坏存储一致性"><a href="#5-2-ConfigStore-是可重入的，但不会破坏存储一致性" class="headerlink" title="5.2 ConfigStore 是可重入的，但不会破坏存储一致性"></a>5.2 ConfigStore 是可重入的，但不会破坏存储一致性</h3><p>现在来看示例里的 ConfigStore：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">ConfigStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setAll</span>(<span class="keyword">_</span> <span class="params">dict</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) &#123;</span><br><span class="line">        storage <span class="operator">=</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigStore 的方法包含两类行为：</p>
<ol>
<li>setAll 是同步写入</li>
<li>currentSnapshot 是 async，但构造快照是同步读取</li>
</ol>
<p>可重入在这里不会造成影响，原因有两点：</p>
<ol>
<li>所有写入都是“整体替换”。<br> 不会出现半写入状态，不会在 await 中间暴露未完成数据，storage 始终保持完整一致。</li>
<li>读取快照也是一次性读取。<br> 它不会在中途 await，也不会依赖内部多步更新，因此即使可重入，也不会打断连续性。</li>
</ol>
<p>也就是说，ConfigStore 的设计本身就避免了可重入带来的典型风险。</p>
<h3 id="5-3-刷新流程属于业务关键路径，因此不能被可重入"><a href="#5-3-刷新流程属于业务关键路径，因此不能被可重入" class="headerlink" title="5.3 刷新流程属于业务关键路径，因此不能被可重入"></a>5.3 刷新流程属于业务关键路径，因此不能被可重入</h3><p>可重入真正会造成隐患的是业务流程，而不是资源层。看一下 ConfigRefreshService：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigFetcher</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">refreshIfNeeded</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这一方法包含多个 await：</p>
<ul>
<li>读取版本号</li>
<li>发出网络请求</li>
<li>写入缓存</li>
<li>获取快照</li>
</ul>
<p>如果这是普通 actor 方法，那么在网络请求的等待期间，可能有其他刷新任务进入，在写入缓存前，其他任务可能更新 storage，版本判断可能在逻辑恢复时变得不再准确，最终导致刷新流程交错执行，顺序错乱。</p>
<p>但示例中采用的是全局 actor ConfigFetcher，它具有一个关键特性，全局 actor 在 await 时不会允许其他相同 actor 的方法插队进入。也就是说，刷新流程从进入到退出始终是独占、一条路跑到底的，不会因为 await 而让其他刷新流程抢占执行权。<strong>刷新流程的不可重入，是整个配置系统稳定性的核心基础</strong>。任何版本判断、写入缓存、快照生成，只能在保证流程连续性的前提下进行。</p>
<h3 id="5-4-为什么-ConfigFetcher-不可重入，而-ConfigStore-可以"><a href="#5-4-为什么-ConfigFetcher-不可重入，而-ConfigStore-可以" class="headerlink" title="5.4 为什么 ConfigFetcher 不可重入，而 ConfigStore 可以"></a>5.4 为什么 ConfigFetcher 不可重入，而 ConfigStore 可以</h3><p>这是架构层的设计选择，ConfigStore 负责“存储的正确性”。可重入不会破坏存储，因为写是原子替换、读是完整快照。<br>ConfigFetcher 负责“流程的顺序性”。流程顺序不能被中断，否则多个刷新可能交叉执行，导致版本倒退或状态覆盖。</p>
<p>两者的角色完全不同：</p>
<ul>
<li>ConfigStore 是状态仓库，适合高吞吐，需要可重入。</li>
<li>ConfigFetcher 是流程调度者，需要绝对顺序，不允许可重入。</li>
</ul>
<p>这种组合形成了一种稳定结构，可重入发生在对业务安全无害的地方，不可重入发生在业务必须保持完整性的地方。这种设计能在保证性能的同时，维持流程级别的正确性。</p>
<h3 id="5-5-可重入真正可能造成问题的场景"><a href="#5-5-可重入真正可能造成问题的场景" class="headerlink" title="5.5 可重入真正可能造成问题的场景"></a>5.5 可重入真正可能造成问题的场景</h3><p>为了理解为何 ConfigFetcher 必须不可重入，可以参考下面的对比示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">UserSession</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> token: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">refreshToken</span>() <span class="keyword">async</span> &#123;</span><br><span class="line">        token <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">1_000_000_000</span>) <span class="comment">// 暂停点</span></span><br><span class="line">        token <span class="operator">=</span> <span class="string">&quot;NEW_TOKEN&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设两个任务同时调用 refreshToken：</p>
<ol>
<li>第一个任务清空 token</li>
<li>任务暂停</li>
<li>第二个任务进入，清空 token</li>
<li>第二个任务恢复后写入自己的 token</li>
<li>第一个任务恢复后写入自己的 token</li>
</ol>
<p>最终 token 的值不确定，完全取决于时序，可重入使得状态被多次覆盖，而方法本身无法表达这种风险。因此凡是状态分阶段更新的逻辑，必须避免可重入：</p>
<ul>
<li>如多步数据库操作</li>
<li>如令牌刷新</li>
<li>如本地配置合并</li>
<li>如资源初始化</li>
<li>如后台同步任务</li>
</ul>
<p>这些流程不能被插队，也不能依赖时序偶然性。</p>
<p>再看示例代码，ConfigStore 内部不会产生部分状态，ConfigFetcher 使流程不可重入，而快照是一次性构建的值类型，版本判断与写入都是在同一流程中执行，UI 不会在后台线程更新，推送也走同一业务隔离域。在这样的结构下，即使 actor 具有可重入能力，业务结果依旧稳定一致。暂停点不会破坏状态，恢复点不会让流程被插队，读取数据也不会读到半更新状态。这种设计可以自动规避可重入风险。</p>
<p><strong>本章小结：可重入本身不是问题，问题是结构是否能接住它</strong><br>Swift actor 的可重入是一把双刃剑。</p>
<ul>
<li>在资源层面，它提高性能，使 actor 多任务下不阻塞。</li>
<li>在流程层面，它可能破坏顺序，必须通过全局 actor 加以约束。</li>
<li>在数据层面，Sendable 防止跨域共享引用导致的数据竞争。</li>
</ul>
<p>获取服务端配置的示例展示了一条可参考的并发路径：</p>
<ul>
<li>资源层可重入但不会破坏一致性</li>
<li>流程层不可重入，保持严格顺序</li>
<li>UI 层固定在主线程，状态安全</li>
<li>快照作为值在隔离域之间安全流动</li>
</ul>
<p>可重入在其中不是风险，而是性能优化手段。真正的重要点在于结构本身：哪些能被插队，哪些不能，哪些必须保持原子性，都由隔离域清晰定义。下一章将从架构角度总结这种分层模式如何推广到更大的业务领域，例如多源配置、后台同步、用户会话管理、服务端推送整合等。</p>
<h2 id="6-Swift-并发在架构中的落地方式"><a href="#6-Swift-并发在架构中的落地方式" class="headerlink" title="6. Swift 并发在架构中的落地方式"></a>6. Swift 并发在架构中的落地方式</h2><p>前几章分别从隔离域、Sendable、Task、可重入这四个角度拆解了 Swift 并发的底层机制。机制背后的目的并不是让语法更漂亮，而是让系统的结构变得清晰、稳定、可推断。</p>
<p>当业务逐渐复杂、访问路径增多、并发量提升时，痛点往往不在于“怎么写异步”，而在于“可变状态是否仍然安全”“流程是否仍然顺序正确”“数据是否能跨域可靠传播”。获取服务端配置这个示例很小，却展示了一个适用于中大型系统的架构模式。这一章将重点说明这套架构如何落地、如何扩展，以及为何它能承托更复杂的业务场景。</p>
<h3 id="6-1-第一层：资源层（ConfigStore）是状态的唯一入口"><a href="#6-1-第一层：资源层（ConfigStore）是状态的唯一入口" class="headerlink" title="6.1 第一层：资源层（ConfigStore）是状态的唯一入口"></a>6.1 第一层：资源层（ConfigStore）是状态的唯一入口</h3><p>资源层的职责非常单纯：守护可变状态，并明确它的访问方式。在示例中，这个角色由 ConfigStore 承担：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actor</span> <span class="title class_">ConfigStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setAll</span>(<span class="keyword">_</span> <span class="params">dict</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) &#123;</span><br><span class="line">        storage <span class="operator">=</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">currentSnapshot</span>() <span class="keyword">async</span> -&gt; <span class="type">ConfigSnapshot</span> &#123;</span><br><span class="line">        <span class="type">ConfigSnapshot</span>(storage: storage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在资源层有几个关键原则：</p>
<ul>
<li>可变状态只能在一个地方修改。</li>
<li>外部只能通过 await 调用受控方法访问内部存储。</li>
<li>内部不暴露部分状态，不允许跨 actor 的共享引用指针流出。</li>
<li>资源层不关心业务顺序，不关心 UI 状态，也不负责数据来源，它的角色就像仓库管理员，只负责让“状态永远正确且完整”。</li>
</ul>
<p>在更大的系统里，任何“被多个任务共享访问的可变状态”都适合放进这种 actor 中，例如用户会话、下载缓存、任务队列、配置相关等。</p>
<h3 id="6-2-第二层：流程层（ConfigRefreshService-ConfigFetcher）定义业务逻辑顺序"><a href="#6-2-第二层：流程层（ConfigRefreshService-ConfigFetcher）定义业务逻辑顺序" class="headerlink" title="6.2 第二层：流程层（ConfigRefreshService + ConfigFetcher）定义业务逻辑顺序"></a>6.2 第二层：流程层（ConfigRefreshService + ConfigFetcher）定义业务逻辑顺序</h3><p>流程层决定“何时读资源层、何时写资源层、何时生成最终结果”。资源层关注状态的正确性，流程层关注状态变化的顺序。示例中的流程层由两部分组成：</p>
<ul>
<li>ConfigRefreshService：刷新逻辑本体</li>
<li>ConfigFetcher：保证刷新逻辑的串行化执行环境</li>
</ul>
<p>刷新流程中包含至少三个对业务顺序非常敏感的阶段：</p>
<ul>
<li>读取本地版本</li>
<li>请求远端配置</li>
<li>写入新配置并生成快照</li>
</ul>
<p>这些步骤必须是顺序且不可被打断的。如果流程层在 await 期间被插入另一条刷新请求，就可能出现“先来的流程写入旧版本，后来的流程写入新版本，再被前者覆盖”的典型并发错乱。</p>
<p>全局 actor ConfigFetcher 的作用是为流程层提供一个不可重入的隔离环境，让每一次刷新逻辑都拥有排他性执行权。这种特性与业务语义天然契合：刷新配置本身就是一种全局顺序化操作。在更多业务中，也能看到类似需求，例如令牌刷新、账号迁移、数据库写入、后台同步调度等，都需要以同样方式集中到一个业务域顺序执行。</p>
<h3 id="6-3-第三层：UI层（ConfigViewModel）管理用户可见状态"><a href="#6-3-第三层：UI层（ConfigViewModel）管理用户可见状态" class="headerlink" title="6.3 第三层：UI层（ConfigViewModel）管理用户可见状态"></a>6.3 第三层：UI层（ConfigViewModel）管理用户可见状态</h3><p>UI层的职责是“响应快照变化并更新 UI”。它不参与网络、不参与版本判断、不参与存储结构，也不负责业务顺序。示例中的界面层由一个简单的 @MainActor ViewModel 构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> snapshot: <span class="type">ConfigSnapshot</span> <span class="operator">=</span> .empty</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> lastError: <span class="type">Error</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 UI 状态都在主线程读写，由 MainActor 自动提供线程安全保证。同时，界面层只接收 ConfigSnapshot 这样的值类型，不会参与存储更新，也不会泄漏资源层的内部结构。</p>
<p>流程层不会反向持有界面层，也不会直接操作界面状态，这让整个架构避免循环依赖和线程混乱。</p>
<h3 id="6-4-三层之间的调用链路形成自然分工"><a href="#6-4-三层之间的调用链路形成自然分工" class="headerlink" title="6.4 三层之间的调用链路形成自然分工"></a>6.4 三层之间的调用链路形成自然分工</h3><p>整个“获取服务端配置”的调用链路可以用一句话概括：<br>UI层开始调用</p>
<ul>
<li>→ 流程层决定顺序</li>
<li>→ 资源层维护状态</li>
<li>→ 流程层返回快照</li>
<li>→ UI 更新最终状态</li>
</ul>
<p>这条链路始终是一条单向的数据流。对应的隔离域组合也清晰稳定：</p>
<ul>
<li>界面层归 MainActor</li>
<li>流程层归 ConfigFetcher</li>
<li>资源层归 ConfigStore</li>
</ul>
<p>快照作为 Sendable 值类型安全地在不同隔离域之间传递，避免了引用共享导致的竞态问题。在结构上，这形成一种自然分工：</p>
<ul>
<li>UI层负责呈现</li>
<li>流程层负责决策</li>
<li>资源层负责存储</li>
</ul>
<p>这种分工保证了纵向隔离，让系统在并发场景下依然保持清晰的职责边界。</p>
<h3 id="6-5-避免在流程层内部出现意外的暂停点"><a href="#6-5-避免在流程层内部出现意外的暂停点" class="headerlink" title="6.5 避免在流程层内部出现意外的暂停点"></a>6.5 避免在流程层内部出现意外的暂停点</h3><p>流程层的方法通常包含多个 await，因此必须确保这些 await 不会破坏业务语义。例如，refreshIfNeeded 中的网络请求是不可避免的 await，但版本判断与写入动作必须处于同一个连续流程中。如果流程层随意加入其他 await，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">token <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="operator">...</span>)</span><br><span class="line">token <span class="operator">=</span> newToken</span><br></pre></td></tr></table></figure>
<p>会造成典型的可重入混乱：暂停让出流程执行权，使得业务逻辑被其他调用插队。</p>
<p>因此流程层需要注意，流程中不能暴露“半完成状态”，流程的 await 必须是业务上允许暂停的位置。流程的最终状态必须由单条路径持续推进。这些行为与资源层不同。资源层允许可重入，因为写入是原子操作；流程层不允许可重入，因为步骤之间存在业务依赖。</p>
<h3 id="6-6-架构的可扩展性：从单一配置走向多模块并发控制"><a href="#6-6-架构的可扩展性：从单一配置走向多模块并发控制" class="headerlink" title="6.6 架构的可扩展性：从单一配置走向多模块并发控制"></a>6.6 架构的可扩展性：从单一配置走向多模块并发控制</h3><p>当业务规模扩大，获取服务端配置这种模式可以自然扩展到更多模块。例如：</p>
<ul>
<li>多个配置来源（默认配置、实验配置、本地覆盖配置）。</li>
<li>多个刷新来源（页面触发、后台自动刷新、服务端推送）。</li>
<li>多个业务模块依赖这一份配置（首页、任务系统、广告模块）。</li>
</ul>
<p>扩展方式通常依然沿用三层结构：</p>
<ul>
<li>每类共享可变状态对应一个 Store（actor）。</li>
<li>每类顺序敏感逻辑对应一个 Global Actor。</li>
<li>每类 UI 对应自己的 ViewModel。</li>
</ul>
<p>这种方式使得系统可以横向扩展多个模块，而不出现锁竞争、线程错乱或状态覆盖问题。</p>
<h3 id="6-7-Swift-并发的架构价值：让状态、流程、界面各司其职"><a href="#6-7-Swift-并发的架构价值：让状态、流程、界面各司其职" class="headerlink" title="6.7 Swift 并发的架构价值：让状态、流程、界面各司其职"></a>6.7 Swift 并发的架构价值：让状态、流程、界面各司其职</h3><p>在获取服务端配置这个示例中，Swift 并发的架构价值体现为三个关键词：</p>
<ul>
<li>隔离，使每一类状态只属于一个领域</li>
<li>不可变，使跨域数据永远安全</li>
<li>顺序，使流程具有业务所需的原子性</li>
</ul>
<p>这些特性组合在一起，使系统具有以下特点：</p>
<ul>
<li>即使大量任务同时触发刷新，最终状态仍然正确。</li>
<li>即使服务端推送与手动刷新交替到来，最终顺序仍然可预测。</li>
<li>即使 UI 多次更新，线程安全仍然由语言机制保障。</li>
<li>即使后台有大量读取需求，资源层仍然保持一致性。</li>
</ul>
<p>当这三层形成固定结构后，系统具备了长期维护能力。新的业务可以自然加入模块，而不破坏并发结构。获取服务端配置只是一个简单示例，但展示了 Swift 并发的核心思想：用隔离划分边界，用任务组织流程，用值类型传递结果，让整个系统在高并发下仍然保持清晰、可靠、可推断。</p>
<p>下一章将结合常见并发问题，展示这些结构如何在工程实践中避免真实业务踩坑，包括版本覆盖、半更新状态泄漏、乱序写入、跨线程 UI 更新等典型场景。</p>
<h2 id="7-常见并发问题与隔离模型的解决方式"><a href="#7-常见并发问题与隔离模型的解决方式" class="headerlink" title="7. 常见并发问题与隔离模型的解决方式"></a>7. 常见并发问题与隔离模型的解决方式</h2><p>我们从真实风险回头审视隔离架构的必要性，并发 bug 往往具有相同特征：偶发、难复现、代码看起来完全没问题，但实际运行会在特定时序下出错。</p>
<p>Swift Concurrency 的隔离体系并不是为了“写法更优雅”，而是为了让这些难以追踪的问题从结构上消失。获取服务端配置这个示例之所以适合作为贯穿案例，就是因为它天然包含几乎所有典型并发风险：本地缓存、多个刷新入口、网络开销、UI 状态更新、服务端推送、多任务并发触发等。</p>
<p>这一章逐一分析这些风险，以及为何在隔离架构下它们都被自然化解，而不需要额外技巧。</p>
<h3 id="7-1-多个任务几乎同时刷新，导致最终版本不可预测"><a href="#7-1-多个任务几乎同时刷新，导致最终版本不可预测" class="headerlink" title="7.1 多个任务几乎同时刷新，导致最终版本不可预测"></a>7.1 多个任务几乎同时刷新，导致最终版本不可预测</h3><p>现实场景中，经常出现多个异步流程在短时间内触发配置刷新：应用冷启动时页面多次触发、多个模块同时校验配置、用户手动刷新、后台定时刷新等。如果刷新流程这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task &#123;</span><br><span class="line">    let remote = try await api.fetchConfig()</span><br><span class="line">    await store.setAll(remote.asDictionary())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要出现至少两个任务竞争刷新，顺序立刻失去确定性，先发请求的任务不一定最先返回，晚写入的版本可能比早写入的旧，最终缓存可能倒退。隔离架构中，这个问题完全被结构消除：</p>
<ul>
<li>所有刷新动作进入 ConfigFetcher（全局 actor）。</li>
<li>ConfigFetcher 是不可重入的，因此刷新按顺序排队。</li>
<li>最终写入一定是“时间上最后一次刷新”的结果。</li>
</ul>
<p>业务上对配置更新的预期就是串行的，隔离模型让这种语义自动成立。</p>
<h3 id="7-2-状态写入如果有多步，可能在-await-暂停时暴露半更新状态"><a href="#7-2-状态写入如果有多步，可能在-await-暂停时暴露半更新状态" class="headerlink" title="7.2 状态写入如果有多步，可能在 await 暂停时暴露半更新状态"></a>7.2 状态写入如果有多步，可能在 await 暂停时暴露半更新状态</h3><p>这是并发系统中最难排查的错误之一，写了部分字段，await 暂停并退出 actor，其他任务读取到了“不完整的配置”，<br>这种情况甚至可能造成白屏、崩溃等问题。在示例中，写入动作被设计成原子性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> store.setAll(remote.asDictionary())</span><br></pre></td></tr></table></figure>
<p>ConfigStore 内部写法是替换整个 storage：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storage <span class="operator">=</span> dict</span><br></pre></td></tr></table></figure>
<p>写入没有多个步骤，也没有把内部状态暴露给外界，因此不存在半更新暴露的机会。这种“整体替换”策略非常可靠，是 actor 内部维护状态时的推荐模式。</p>
<h3 id="7-3-刷新流程在等待网络返回时被插队，导致流程逻辑混乱"><a href="#7-3-刷新流程在等待网络返回时被插队，导致流程逻辑混乱" class="headerlink" title="7.3 刷新流程在等待网络返回时被插队，导致流程逻辑混乱"></a>7.3 刷新流程在等待网络返回时被插队，导致流程逻辑混乱</h3><p>网络请求是长暂停点，actor 会在 await 时让出执行权。如果刷新流程放在普通 actor 中，可能出现这样的时序：</p>
<ul>
<li>流程 A：判断本地版本过期 → await 网络</li>
<li>流程 B：也判断本地版本过期 → await 网络</li>
<li>流程 A 恢复：写版本 2</li>
<li>流程 B 恢复：写版本 1（覆盖新版本）</li>
</ul>
<p>最终状态可能倒退。示例中刷新流程被挂载在 ConfigFetcher（全局 actor）上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigFetcher</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">refreshIfNeeded</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">ConfigSnapshot</span></span><br></pre></td></tr></table></figure>
<p>全局 actor 的执行模型保证await 虽然会放弃线程，但不会让流程本身被其他刷新插入。刷新逻辑从第一行到最后一行都是排他执行。这让版本判断和写入之间的因果关系永远成立。</p>
<h3 id="7-4-UI-在后台线程更新，容易导致崩溃或状态跳跃"><a href="#7-4-UI-在后台线程更新，容易导致崩溃或状态跳跃" class="headerlink" title="7.4 UI 在后台线程更新，容易导致崩溃或状态跳跃"></a>7.4 UI 在后台线程更新，容易导致崩溃或状态跳跃</h3><p>UIKit 和 SwiftUI 都要求UI更新必须发生在主线程。在多线程系统里，一旦有人忘记切换线程就会出现瞬间崩溃，再加上异步链路越写越长，问题越来越难发现。示例中的界面层被明确限制在 MainActor：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConfigViewModel</span> &#123; <span class="operator">...</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这样ViewModel 的属性赋值始终发生在主线程，后台线程的刷新不会直接接触 UI 状态。不需要任何DispatchQueue.main.async。这类线程安全问题从源头被清除，界面层变得可预测。</p>
<h3 id="7-5-共享引用对象跨隔离传递，导致意外的数据竞争"><a href="#7-5-共享引用对象跨隔离传递，导致意外的数据竞争" class="headerlink" title="7.5 共享引用对象跨隔离传递，导致意外的数据竞争"></a>7.5 共享引用对象跨隔离传递，导致意外的数据竞争</h3><p>典型错误写法是后台任务解析一个配置对象（class），丢给 UI，UI 读取对象字段，后台又修改同一个对象引用。UI 和后台同时读写同一块内存，就会产生数据竞争。示例中，可以通过 ConfigSnapshot 避免这种风险：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigSnapshot</span>: <span class="title class_ inherited__">Sendable</span></span><br></pre></td></tr></table></figure>
<p>它是值类型，不共享引用，在跨隔离传递时会被复制，UI 拿到的 snapshot 永远不会被后台修改。Swift 在编译期验证 Sendable，让跨域数据变得彻底安全。</p>
<h3 id="7-6-服务端推送与手动刷新可能乱序执行，导致最终状态错误"><a href="#7-6-服务端推送与手动刷新可能乱序执行，导致最终状态错误" class="headerlink" title="7.6 服务端推送与手动刷新可能乱序执行，导致最终状态错误"></a>7.6 服务端推送与手动刷新可能乱序执行，导致最终状态错误</h3><p>推送和手动刷新都是异步事件，如果没有统一调度，很容易出现以下情况：推送写入版本 5，而手动刷新写入版本 3<br>，最终状态回到旧版本。示例中，推送逻辑同样进入 ConfigFetcher：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigFetcher</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">applyPushedConfig</span>(<span class="keyword">_</span> <span class="params">response</span>: <span class="type">RemoteConfigResponse</span>) <span class="keyword">async</span></span><br></pre></td></tr></table></figure>
<p>于是无论事件来源是什么，都进入同一个业务隔离域。顺序完全由到达的先后决定，而不是线程时序。最终状态始终是序列中最后一个更新事件的结果。这是 Swift 并发体系对“复杂事件源”最具价值的能力之一。</p>
<h3 id="7-7-任务取消不生效，后台还在继续执行旧逻辑"><a href="#7-7-任务取消不生效，后台还在继续执行旧逻辑" class="headerlink" title="7.7 任务取消不生效，后台还在继续执行旧逻辑"></a>7.7 任务取消不生效，后台还在继续执行旧逻辑</h3><p>很多时候可能出现这种情况，页面已经销毁，任务仍旧在后台跑，结果返回来修改了一个已经释放或不再需要的对象。Swift Concurrency 提供了自然的取消行为。例如 fetchConfig 使用 sleep 模拟网络：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Task</span>.sleep(nanoseconds: <span class="operator">...</span>)</span><br></pre></td></tr></table></figure>
<p>sleep 本身就是可取消挂起点，一旦上层 Task 被取消，sleep 会直接抛出 CancellationError，当前刷新流程终止，不会进入 store.setAll。这让取消机制天然有效，不需要额外编码。</p>
<h3 id="7-8-隔离本质上不是“避免-bug”，而是“消灭-bug-的发生条件”"><a href="#7-8-隔离本质上不是“避免-bug”，而是“消灭-bug-的发生条件”" class="headerlink" title="7.8 隔离本质上不是“避免 bug”，而是“消灭 bug 的发生条件”"></a>7.8 隔离本质上不是“避免 bug”，而是“消灭 bug 的发生条件”</h3><p>在获取服务端配置这套架构中，常见并发问题不是靠技巧性写法规避，而是靠结构本身不再允许这些问题发生。可以总结成一句话：当业务状态有归属、业务流程有顺序、数据传递不可变、界面更新有线程保障时，并发问题自然消失。<br>为了更清晰，可以用下面这张简明对应表概括：</p>
<table>
<thead>
<tr>
<th><strong>并发风险</strong></th>
<th><strong>架构中对应的解决机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>多个刷新覆盖</td>
<td>ConfigFetcher 串行业务顺序</td>
</tr>
<tr>
<td>半更新状态泄漏</td>
<td>ConfigStore 原子性写入</td>
</tr>
<tr>
<td>刷新流程被打断</td>
<td>全局 actor 不可重入</td>
</tr>
<tr>
<td>UI 跨线程更新</td>
<td>@MainActor</td>
</tr>
<tr>
<td>数据竞争</td>
<td>ConfigSnapshot + Sendable</td>
</tr>
<tr>
<td>推送与手动刷新乱序</td>
<td>统一进入 ConfigFetcher</td>
</tr>
<tr>
<td>任务取消失效</td>
<td>await 提供天然取消点</td>
</tr>
</tbody></table>
<center>表7-1 Swift 并发风险项与解决机制对照表</center>

<p>这些机制叠加在一起，让系统具备高度一致性，并发不再是需要谨慎面对的问题。下一章将总结 Swift 并发的整体思路，并从更宏观的角度给出这套模式的扩展方向与适用场景。</p>
<h2 id="8-Swift-并发的整体视野：从隔离模型构建可预测的系统"><a href="#8-Swift-并发的整体视野：从隔离模型构建可预测的系统" class="headerlink" title="8. Swift 并发的整体视野：从隔离模型构建可预测的系统"></a>8. Swift 并发的整体视野：从隔离模型构建可预测的系统</h2><p>获取服务端配置是一个规模不大、逻辑也不复杂的案例，却覆盖了现代应用中常见的并发难点：共享状态、长耗时任务、多个入口触发、UI 驱动、推送事件、取消机制……。整个示例展示了：<strong>Swift Concurrency 的真正价值不在于 async&#x2F;await，而在于它有了一个系统的结构。</strong> 这种结构不是人为制定的规范，而是由语言层面的隔离机制形成的。当隔离域、任务调度、数据传递方式组合在一起时，系统的稳定性不再依赖经验，而是变成可验证、可推断的一套规则。下面从全局视角总结这些规则如何协同工作。</p>
<h3 id="8-1-Swift-并发的核心思想"><a href="#8-1-Swift-并发的核心思想" class="headerlink" title="8.1 Swift 并发的核心思想"></a>8.1 Swift 并发的核心思想</h3><p>async&#x2F;await 的意义在于让异步链路可阅读、可组合，但它并不解决并发安全。真正决定系统稳不稳定的，是“边界”：</p>
<ul>
<li>哪些状态可以被访问？</li>
<li>哪个线程负责 UI？</li>
<li>哪条逻辑具有排他性？</li>
<li>哪些值可以跨线程传递？</li>
<li>哪个执行环境处理特定任务？</li>
</ul>
<p>Swift 给这些问题提供了结构化答案：</p>
<ul>
<li>MainActor → UI 的唯一入口</li>
<li>ConfigFetcher → 刷新流程的唯一调度域</li>
<li>ConfigStore → 缓存状态的唯一读写入口</li>
<li>ConfigSnapshot → 跨域传输的唯一载体</li>
</ul>
<p>这四个角色构成了整个异步系统的骨架。任何并发行为都必须沿着这些骨架行走，从而保持一致性。</p>
<h3 id="8-2-获取服务端配置示例构建的三层体系"><a href="#8-2-获取服务端配置示例构建的三层体系" class="headerlink" title="8.2 获取服务端配置示例构建的三层体系"></a>8.2 获取服务端配置示例构建的三层体系</h3><p>这套示例的结构可以用“三层隔离”概括：</p>
<ol>
<li><strong>第一层：界面层（MainActor）</strong><br> 承载所有用户可见状态，包括当前快照、是否加载中、错误提示；天然绑定主线程，保证界面更新的正确性。</li>
<li><strong>第二层：业务流程层（ConfigFetcher + ConfigRefreshService）</strong><br> 承载获取配置的业务逻辑与顺序要求；通过全局 actor 保证刷新流程不会交错执行</li>
<li><strong>第三层：资源层（ConfigStore）</strong><br> 承载可变状态，是整个系统状态的一致性中心；actor 的串行访问保证不会发生 data race；通过原子性整体写入避免半更新状态。</li>
</ol>
<p>三层之间互不越界，各自承担独立职责。这种结构保证系统能在并发条件下保持清晰的状态流动。</p>
<h3 id="8-3-Swift-并发是如何让系统“可预测”的"><a href="#8-3-Swift-并发是如何让系统“可预测”的" class="headerlink" title="8.3 Swift 并发是如何让系统“可预测”的"></a>8.3 Swift 并发是如何让系统“可预测”的</h3><p>“可预测”是并发编程中最难获得的特性。许多语言提供 async、future、promise，却没有提供结构性的隔离手段，最终依旧依赖锁、队列和经验。Swift 则以以下方式建立了可预测性：</p>
<ol>
<li><strong>状态只存在一个入口</strong><br> ConfigStore 让共享可变状态集中在一个 actor 中，所有读写都必须经过 await 调度。</li>
<li><strong>业务序列化而非线程序列化</strong><br> ConfigFetcher 让刷新流程的因果关系永远成立。并发任务不会破坏业务顺序。</li>
<li><strong>UI 始终在正确线程中更新</strong><br> MainActor 自动保证界面修改只发生在主线程。不需要 GCD，也没有遗漏风险。</li>
<li><strong>数据流是不可变的</strong><br> ConfigSnapshot 是 Sendable 的值类型，没有共享引用，不可能发生跨线程修改。</li>
<li><strong>推送事件、安全合流</strong><br> 服务端推送、手动刷新、自动刷新都进入同一个业务域。顺序天然一致，逻辑不会分叉。这一体系将原本“靠习惯和技巧维持”的异步系统，变成“靠语言和结构保证”的系统。</li>
</ol>
<h3 id="8-4-隔离模型的可扩展性"><a href="#8-4-隔离模型的可扩展性" class="headerlink" title="8.4 隔离模型的可扩展性"></a>8.4 隔离模型的可扩展性</h3><p>获取服务端配置只是一个示例，但这种并发结构可自然扩展到更复杂的模块，例如：</p>
<ul>
<li>功能开关中心；</li>
<li>会话管理；</li>
<li>下载中心；</li>
<li>多源同步系统；</li>
<li>后端推送与本地存储合流；</li>
<li>基于策略的线上配置管理；</li>
<li>复杂 UI 状态同步；</li>
<li>模块化架构中的跨模块状态共享。</li>
</ul>
<p>在这些场景中，都可以复用相同的结构思想：</p>
<ul>
<li>资源层隔离可变状态</li>
<li>流程层隔离业务顺序</li>
<li>界面层隔离用户可见状态</li>
<li>数据以不可变形式跨域传递</li>
</ul>
<p>这让模块变得稳健、可扩展、易维护。</p>
<h3 id="8-5-从“面向线程编程”到“隔离式编程”"><a href="#8-5-从“面向线程编程”到“隔离式编程”" class="headerlink" title="8.5 从“面向线程编程”到“隔离式编程”"></a>8.5 从“面向线程编程”到“隔离式编程”</h3><p>在传统并发体系中，很多问题必须通过“线程意识”解决：这里应该上锁，那里需要回到主线程，这个对象不能跨线程传，那个流程要避免并发。Swift Concurrency 的思路完全相反：</p>
<ul>
<li>无需关心线程，而是关心隔离域。</li>
<li>无需管理锁，而是管理状态归属。</li>
<li>无需判断当前在哪个线程，而是让 MainActor 自动决定。</li>
<li>无需担心谁先完成，而是让 Global Actor 决定顺序。</li>
<li>无需拷贝整个对象，而是让 Sendable 保证不可变性。</li>
</ul>
<p>从线程思维跳到隔离思维，是 Swift Concurrency 真正提升开发质量的地方。</p>
<h3 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h3><p>整个系统构建下来，可以用三句话总结 Swift 并发的真正目标：</p>
<ul>
<li><strong>状态有归属。</strong><br>  每一份可变状态都属于一个独立的 actor，访问方式受约束，永远不会裸奔。</li>
<li><strong>流程有顺序。</strong><br>  业务逻辑的执行顺序不依赖线程竞争，而是由 Global Actor 明确控制。</li>
<li><strong>数据有形状。</strong><br>  跨域传递的值必须 Sendable，可预测、可验证、不可变。</li>
</ul>
<p>这三点结合起来，构成了 Swift 并发的稳健性基础。</p>
<p>Swift Concurrency 并没有发明新线程模型，而是给现有的并发世界增加了“结构”。这种结构使得应用在面对并发压力时仍然保持稳定，让复杂系统更容易推断与扩展。</p>
<p>未来无论遇到用户会话、数据同步、推送事件融合、复杂 UI 状态管理，都可以沿着这条思路构建可预测的并发体系。这样构建出来的系统，不仅稳定，而且优雅——因为它拥有清晰的边界、有序的数据流，以及默认正确的行为。</p>
<h2 id="9-备注"><a href="#9-备注" class="headerlink" title="9. 备注"></a>9. 备注</h2><p><a target="_blank" rel="noopener" href="https://gist.github.com/keychankc/be207faff229cc2b97da168aaf9aadb7">获取服务端配置示例代码</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>KeyChan
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://www.keychan.xyz/2025/12/09/046-swift-concurrency/" title="Swift 隔离式并发实践：actor、Global Actor 与 Sendable">https://www.keychan.xyz/2025/12/09/046-swift-concurrency/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://x.com/keychankc">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Swift/" rel="tag"># Swift</a>
              <a href="/tags/Swift%E5%B9%B6%E5%8F%91/" rel="tag"># Swift并发</a>
              <a href="/tags/actor/" rel="tag"># actor</a>
              <a href="/tags/AsyncSequence/" rel="tag"># AsyncSequence</a>
              <a href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag"># 协程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/05/045-asynchronous-transformation-of-uikit-project/" rel="prev" title="UIKit 项目异步改造：Combine、async/await、@Published">
                  <i class="fa fa-angle-left"></i> UIKit 项目异步改造：Combine、async/await、@Published
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/12/16/047-flight-control-software-architecture-communication-system/" rel="next" title="「无人机⑤」从数据到决策：飞控软件架构与通信体系">
                  「无人机⑤」从数据到决策：飞控软件架构与通信体系 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">KeyChan</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">432k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/keychankc" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="/js/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/ribbon.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://comment.mengyajia.com","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":false,"pageview":false,"placeholder":"欢迎评论~","emoji":["https://unpkg.com/@waline/emojis@1.1.0/qq"],"requiredMeta":["nick","mail"],"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/2025/12/09/046-swift-concurrency/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
